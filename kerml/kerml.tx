/* Elements */
RootNamespace:
      ( ownedRelationship += OwnedDocumentation
      | ownedRelationship += NamespaceMember
      | ownedRelationship += AliasMember
      | ownedRelationship += Import
      )*
;

Element:
    'element' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)
    (';' | '{'
        (   ownedRelationship += OwnedRelationship
            | ownedRelationship += OwnedDocumentation
            | ownedRelationship += OwnedTextualRepresentationAnnotation
        )*
    '}')
;

/* =============================================================== */
/* Relationships */
Relationship:
    'relationship' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
        ('from' source+=[QualifiedName][','])?
        ('to' target+=[QualifiedName][','])?
    (';' | '{'
        ownedRelatedElement+=RelationshipOwnedElement
    '}')
;

OwnedRelationship:
    'relationship' ('<' name=QualifiedName '>')? ('to' target+=[QualifiedName][','])?
    (';' | '{'
        ownedRelatedElement+=RelationshipOwnedElement
    '}')
;

RelationshipOwnedElement:
// TODO: Element and relationship isn't 100% correct but works for now
//  Fix with the OwnedRelatedElement and OwnedRelatedElementOrRelationship rule
      ownedRelatedElement += Element
    | ownedRelatedElement += Relationship
    | ownedRelationship += OwnedDocumentation
    | ownedRelationship += OwnedTextualRepresentationAnnotation
;


/* =============================================================== */
/* Comments */
ModelComment:
	( 'comment' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)
	  'about' annotation += Annotation
      //{ ownedRelationship += annotation }
      ownedRelationship += [QualifiedName]
	  ( ',' ownedRelationship += Annotation )*
	  | ( 'comment' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName) )?
	  ownedRelationship += ElementAnnotation
      //{ ownedRelationship += annotation }
      ownedRelationship += [QualifiedName]
	)
	body = /(?ms)\/\*(.*?)\*\//
;
Annotation:
	annotatedElement = [QualifiedName]
;
ElementAnnotation:
    annotatedElement = [QualifiedName]
;

/* =============================================================== */
/* DOCUMENTATION */
OwnedDocumentation:
    documentingComment=DocumentationComment
;
DocumentationComment:
    'doc' ('<' name = Name '>' )? body=/(?ms)\/\*(.*?)\*\//
;
PrefixDocumentation:
	documentingComment=PrefixDocumentationComment
;
PrefixDocumentationComment:
	( 'doc' ( '<' name = Name '>' )? )? body=/(?ms)\/\*\*(.*?)\*\//
;

/* =============================================================== */
/* Textual Representation */
OwnedTextualRepresentationAnnotation:
    ownedRelatedElement += OwnedTextualRepresentation
;
OwnedTextualRepresentation:
    ( 'rep' ( name=QualifiedName )? )?
    'language' language=QuotedID body=REGULAR_COMMENT
    // { annotation += a }
;
TextualRepresentation:
    (   'rep' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
        'about' annotation+=Annotation
    | ( 'rep' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? )?
        ElementAnnotation
    )
    'language' language=QuotedID body=REGULAR_COMMENT
;

/* =============================================================== */
/* Namespace */
Namespace:
    'namespace' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)
    (';' | '{'
      ( ownedRelationship += OwnedDocumentation
      | ownedRelationship += NamespaceMember
      | ownedRelationship += AliasMember
      | ownedRelationship += Import
      )*
    '}')
;
MemberPrefix:
    ( visibility = VisibilityIndicator )?
;
NamespaceMember:
    MemberPrefix
      ( ownedMemberElement=NonFeatureElement )
    | ( ownedMemberElement=FeatureElement )
    | ( 'feature'? ( name=QualifiedName )? 'is'
       ownedMemberElement = FeatureChain )
;
NonFeatureMember:
    MemberPrefix
    ownedMemberElement=NonFeatureElement
;
FeatureNamespaceMember:
    MemberPrefix
    ownedMemberElement=FeatureElement
;
ChainFeatureMember:
    MemberPrefix
    'feature'? ( name=QualifiedName )? 'is'
    ownedMemberElement = FeatureChain
;
AliasMember:
    MemberPrefix
    'alias' name=QualifiedName 'for'
    memberElement=[QualifiedName] ';'
;
Import:
    ( visibility = VisibilityIndicator )?
    'import' ( isImportAll ?= 'all' )?
        ( ImportedNamespace
        | ImportedFilterPackage ) ';'
;
ImportedNamespace:
    ( importedNamespace = [QualifiedName] '::' )?
    ( importedName=QualifiedName | '*' )
    ( '::' isRecursive ?= '**' )?
;
ImportedFilterPackage:
    ownedRelatedElement += FilterPackage
;
FilterPackage:
    ownedRelationship += FilterPackageImport
    ( ownedRelationship += FilterPackageMember )+
;
FilterPackageImport:
    ImportedNamespace
;
FilterPackageMember:
    '[' condition=OwnedExpression ']'
;
VisibilityIndicator :
    'public' | 'private' | 'protected'
;

NonFeatureElement:
    Element
    | Relationship
    | ModelComment
    | TextualRepresentation
    | AnnotatingFeature
    | Namespace
    | Type
    | Classifier
    | DataType
    | Class
    | Structure
    | Association
    | AssociationStructure
    | Interaction
    | Behavior
    | Function
    | Predicate
    | Multiplicity
    | Package
    | Conjugation
    | Subclassification
    | Disjoining
    | FeatureTyping
    | Subsetting
    | Redefinition
    | TypeFeaturing
;
FeatureElement:
      Feature
    | Step
    | Expression
    | BooleanExpression
    | Invariant
    | Connector
    | BindingConnector
    | Succession
    | ItemFlow
    | SuccessionItemFlow
;

FullyQualifiedID[noskipws]:
    /\s*/-
    QuotedID+['::']
    /\s*/-
;
QuotedID:
    '"'?- Name '"'?-
;

/* =============================================================== */
/* CORE LAYER RULES */
/* =============================================================== */

/* =============================================================== */
/* TYPES */
Type:
    ( isAbstract ?= 'abstract' )? 'type'
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
        SPECIALIZES ownedRelationship += OwnedSpecialization
    ( ',' ownedRelationship += OwnedSpecialization )*
        | CONJUGATES ownedRelationship += OwnedConjugation
    )+
    DisjoiningPart?
    (
        ';' | '{'
            (
              documentation += OwnedDocumentation
             | ownedRelationship += NonFeatureMember
             | ownedRelationship += FeatureMember
             | ownedRelationship += AliasMember
             | ownedRelationship += Import
            )*
        '}'
    )
    ;

TypeBody:
    ';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}'
    ;
TypeBodyElement:
    documentation += OwnedDocumentation
    ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
;

SpecializationPart:
    SPECIALIZES ownedRelationship += OwnedSpecialization
    ( ',' ownedRelationship += OwnedSpecialization )*
    ;

ConjugationPart:
    CONJUGATES ownedRelationship += OwnedConjugation
;

DisjoiningPart:
    'disjoint' 'from' ownedRelationship += OwnedDisjoining
    ( ',' ownedRelationship += OwnedDisjoining )*
    ;

/* =============================================================== */
/* SPECIALIZATION */
Specialization:
    ( 'specialization' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?)?
    'subtype'     (subsettingFeature = [QualifiedName] | ownedRelatedElement += FeatureChain)
    SPECIALIZES     subsettedFeature = [QualifiedName]
    | ownedRelatedElement += FeatureChain';'
    ;
OwnedSpecialization :
    subsettedFeature = [QualifiedName]
    | ownedRelatedElement += FeatureChain
    ;

/* =============================================================== */
/* CONJUGATION */
Conjugation:
    ( 'conjugation' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? )?
    'conjugate'
    (
        conjugatedType=[QualifiedName]
        | conjugatedType = FeatureChain
        // TODO: Do this in the class instantiation
        //  { ownedRelatedElement += conjugatedType }
    )
    CONJUGATES
    (
        originalType=[QualifiedName]
        | originalType = FeatureChain
        // TODO: Do this in the class instantiation
        //  { ownedRelatedElement += originalType }
    ) ';'
;

OwnedConjugation:
      originalType=[QualifiedName]
    | originalType = FeatureChain
    // TODO: Do this in the class instantiation
    //  { ownedRelatedElement += originalType }
;

/* =============================================================== */
/* DISJOINING */
Disjoining:
    ( 'disjoining' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? )?
    'disjoint' ( typeDisjoined = [QualifiedName]
    | typeDisjoined = FeatureChain
    // TODO: Do this in the class instantiation
    //  { ownedRelatedElement += typeDisjoined }
    )
    'from'
    ( disjoiningType = [QualifiedName]
    | disjoiningType = FeatureChain
    // TODO: Do this in the class instantiation
    //  { ownedRelatedElement += disjoiningType }
    ) ';'
;
OwnedDisjoining:
    disjoiningType = [QualifiedName]
    | disjoiningType = FeatureChain
    // TODO: Do this in the class instantiation
    //  { ownedRelatedElement += disjoiningType }
;

/* =============================================================== */
/* FEATURE MEMBER */
FeatureMember :
      MemberPrefix 'member' ownedMemberElement = FeatureElement
    | MemberPrefix ownedMemberFeature = FeatureElement
    | MemberPrefix 'feature'? ( name=QualifiedName )? 'is'
      memberFeature = [QualifiedName]
    | ChainFeatureMember
;
UnownedFeatureMember:
    MemberPrefix 'feature'? ( name=QualifiedName )? 'is'
    memberFeature = [QualifiedName]
;

/* =============================================================== */
/* CLASSIFIERS */
Classifier:
    ( isAbstract ?= 'abstract' ) 'classifier'
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;

ClassifierDeclaration:
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    ;
SuperclassingPart:
    SPECIALIZES ownedRelationship += OwnedSubclassification
    ( ',' ownedRelationship += OwnedSubclassification )*
    ;

/* =============================================================== */
/* SUBCLASSIFICATION */
Subclassification:
    ( 'specialization' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? )?
    'subclassifier' subclassifer = [QualifiedName]
    SPECIALIZES superclassifer = [QualifiedName] ';'
    ;
OwnedSubclassification:
    superclassifier = [QualifiedName]
    ;

/* =============================================================== */
/* FEATURES */
FeaturePrefix:
    ( direction = FeatureDirection )?
    ( isAbstract ?= 'abstract' )?
    ( isComposite ?= 'composite' | isPortion ?= 'portion' )?
    ( isReadOnly ?= 'readonly' )?
    ( isDerived ?= 'derived' )?
    ( isEnd ?= 'end' )?
;
FeatureDirection :
    'in' | 'out' | 'inout'
;
Feature:
    FeaturePrefix 'feature'?
    ( isSufficient ?= 'all' )?
    (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( FeatureSpecializationPart | ConjugationPart)?
    DisjoiningPart? TypeFeaturingPart?
    ValuePart?
    ( ';' | '{'
        (
            ownedRelationship += NonFeatureMember
            | ownedRelationship += FeatureMember
            | ownedRelationship += AliasMember
            | ownedRelationship += Import
        )*
        '}'
    )
;

FeatureDeclaration:
    ( isSufficient ?= 'all' )?
    (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( FeatureSpecializationPart | ConjugationPart )?
    DisjoiningPart?
    TypeFeaturingPart?
;

TypeFeaturingPart:
    'featured' 'by' ownedRelationship += OwnedTypeFeaturing
    ( ',' ownedTypeFeaturing += OwnedTypeFeaturing )*
;
FeatureSpecializationPart:
      FeatureSpecialization+ MultiplicityPart? FeatureSpecialization*
    | ( ownedRelationship += OwnedMultiplicity
        | ( ownedRelationship += OwnedMultiplicity )?
        ( (isOrdered ?= 'ordered')? (isUnique ?= 'nonunique')? )#
      )
      (
        Typings | Subsettings | Redefinitions
      )*
    ;
MultiplicityPart:
      ownedRelationship += OwnedMultiplicity
    | ( ownedRelationship += OwnedMultiplicity )?
    ( (isOrdered ?= 'ordered')? (isUnique ?= 'nonunique')? )#
    ;

FeatureSpecialization :
    Typings | Subsettings | Redefinitions
;
Typings:
      TYPED_BY ownedRelationship += OwnedFeatureTyping ( ',' ownedRelationship += OwnedFeatureTyping )*
  ;
TypedBy:
    TYPED_BY ownedRelationship += OwnedFeatureTyping
;
Subsettings:
    ( ':>'  | 'subsets' ) ownedRelationship += OwnedSubsetting ( ',' ownedRelationship += OwnedSubsetting )*
;
Subsets:
    ( ':>'  | 'subsets' ) ownedRelationship += OwnedSubsetting
;
Redefinitions:
    Redefines ( ',' ownedRelationship += OwnedRedefinition )*
;
Redefines:
    REDEFINES ownedRelationship += OwnedRedefinition
;

/* =============================================================== */
/* TYPE FEATURING */
TypeFeaturing:
    'featuring' ( (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? 'of')?
    featureOfType = [QualifiedName]
    'by' featuringType = [QualifiedName] ';'
    ;
OwnedTypeFeaturing:
    featuringType = [QualifiedName]
    ;

/* =============================================================== */
/* FEATURING TYPE */
FeatureTyping:
    ( 'specialization' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? )?
    'typing' typedFeature = [QualifiedName]
    TYPED_BY general = [QualifiedName] ';'
;

OwnedFeatureTyping :
    general = [QualifiedName]
;

/* =============================================================== */
/* SUBSETTING */
Subsetting:
    ( 'specialization' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? )?
    'subset'
    (subsettingFeature = [QualifiedName]
    | ownedRelatedElement += FeatureChain)
    ( ':>'  | 'subsets' )
    (
     subsettedFeature = [QualifiedName]
    | ownedRelatedElement += FeatureChain
    )
    ';'
;
OwnedSubsetting:
    subsettedFeature = [QualifiedName]
    | ownedRelatedElement += FeatureChain
;

/* =============================================================== */
/* SUBSETTING */
Redefinition:
    ( 'specialization' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?   )?
    'redefinition'
    ( specific = [Feature|QualifiedName]
    | specific += FeatureChain )
    REDEFINES
    ( general = [Feature|QualifiedName]
    | general += FeatureChain )
    ';'
;

SpecificType:
    specific = [Feature|QualifiedName]
    | specific += FeatureChain
;

GeneralType:
    general = [Feature|QualifiedName]
    | general += FeatureChain
;

OwnedRedefinition:
    general = [QualifiedName]
  | general += FeatureChain
;

/* =============================================================== */
/* FEATURE CHAINING */
FeatureChain:
    ownedRelationship += OwnedFeatureChaining
    ( '.' ownedRelationship += OwnedFeatureChaining )+
;

OwnedFeatureChaining:
    chainingFeature = [QualifiedName]
;

/* =============================================================== */
/* KERNEL LAYER RULES */
/* =============================================================== */

/* =============================================================== */
/* DATA TYPES */
DataType:
    ( isAbstract ?= 'abstract' )? 'datatype'
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
;

/* =============================================================== */
/* CLASSES */
Class:
    ( isAbstract ?= 'abstract' )? 'class'
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
;

/* =============================================================== */
/* STRUCTURES */
Structure:
    ( isAbstract ?= 'abstract' )? 'struct'
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}');

/* =============================================================== */
/* ASSOCIATIONS */
Association:
    ( isAbstract ?= 'abstract' )? 'assoc'
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
;
AssociationStructure:
    ( isAbstract ?= 'abstract' )? 'assoc' 'struct'
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;

/* =============================================================== */
/* CONNECTORS */
Connector:
    FeaturePrefix 'connector'
    ConnectorDeclaration
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;
ConnectorDeclaration:
    BinaryConnectorDeclaration | NaryConnectorDeclaration
    ;
BinaryConnectorDeclaration:
    ( FeatureDeclaration? 'from' | isSufficient ?= 'all' 'from'? )?
    ownedRelationship += ConnectorEndMember 'to'
    ownedRelationship += ConnectorEndMember
    ;
NaryConnectorDeclaration:
    FeatureDeclaration
    ( '(' ownedRelationship += ConnectorEndMember ','
        ownedRelationship += ConnectorEndMember
        ( ',' ownedRelationship += ConnectorEndMember )* ')' )?
    ;
ConnectorEndMember:
    ( name = Name ':>' )? ownedMemberFeature = ConnectorEnd
    ;
ConnectorEnd:
    ownedRelationship += OwnedSubsetting
    ( ownedRelationship += OwnedMultiplicity )?
    ;

/* =============================================================== */
/* BINDING CONNECTORS */
BindingConnector:
    FeaturePrefix 'binding'
    BindingConnectorDeclaration
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;

BindingConnectorDeclaration:
    ( FeatureDeclaration 'of' | isSufficient ?= 'all' 'of'? )?
    ownedRelationship += ConnectorEndMember '='
    ownedRelationship += ConnectorEndMember
    ;

/* =============================================================== */
/* SUCCESSIONS */
Succession:
    FeaturePrefix 'succession'
    SuccessionDeclaration
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;
SuccessionDeclaration:
    ( FeatureDeclaration? 'first' | isSufficient ?= 'all' 'first'? )?
    ownedRelationship += ConnectorEndMember 'then'
    ownedRelationship += ConnectorEndMember
    ;

/* =============================================================== */
/* BEHAVIORS */
Behavior:
    ( isAbstract ?= 'abstract ')? 'behavior'
    BehaviorDeclaration
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;
BehaviorDeclaration:
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    ParameterList?
    ;
ParameterList:
    '(' ( ownedRelationship += ParameterMember
    ( ',' ownedRelationship += ParameterMember )* )? ')'
    ;
ParameterMember:
    ownedMemberParameter = ParameterDeclaration
    ;
ParameterDeclaration:
      FeatureParameterDeclaration
    | StepParameterDeclaration
    | ExpressionParameterDeclaration
    | BooleanExpressionParameterDeclaration
    ;
FeatureParameterDeclaration:
    ( direction = FeatureDirection )?
    'feature'? ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ParameterSpecializationPart
    ;
StepParameterDeclaration:
    ( direction = FeatureDirection )?
    'step' ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ParameterSpecializationPart
    ;
ExpressionParameterDeclaration:
    ( direction = FeatureDirection )?
    'expr' ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ParameterSpecializationPart
    ;
BooleanExpressionParameterDeclaration:
    ( direction = FeatureDirection )?
    'bool' ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ParameterSpecializationPart
    ;
ParameterSpecializationPart:
    ParameterSpecialization*
    ( ownedRelationship += OwnedMultiplicity
      | ( ownedRelationship += OwnedMultiplicity )?
      ( (isOrdered ?= 'ordered')? (isUnique ?= 'nonunique')? )#
    )?
    ParameterSpecialization*
//    ParameterSpecialization* MultiplicityPart? ParameterSpecialization*
    ;
ParameterSpecialization:
    TYPED_BY ownedRelationship += OwnedFeatureTyping | ( ':>'  | 'subsets' ) ownedRelationship += OwnedSubsetting | REDEFINES ownedRelationship += OwnedRedefinition
    ;

/* =============================================================== */
/* STEPS */
Step:
    FeaturePrefix 'step'
    StepDeclaration
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;

StepDeclaration:
    FeatureDeclaration ( ValuePart | StepParameterList )?
    ;
StepParameterList:
    '(' ( ownedRelationship += StepParameterMember
    ( ',' ownedRelationship += StepParameterMember )* )? ')'
    ;
StepParameterMember:
    ownedMemberParameter = StepParameter
    ;
StepParameter:
    ParameterDeclaration ValuePart?
    ;

/* =============================================================== */
/* FUNCTIONS */
Function:
    ( isAbstract ?= 'abstract' )? 'function'
    FunctionDeclaration FunctionBody
    ;
FunctionDeclaration:
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?

    ParameterList ReturnParameterPart?
    ;
ReturnParameterPart:
    ownedRelationship += ReturnParameterMember
    ;
ReturnParameterMember:
    'return'? ownedMemberParameter = ParameterDeclaration
    ;
FunctionBody:
      ';'
    | '{'
        ( TypeBodyElement | ownedRelationship += ReturnFeatureMember )*
        ( ownedRelationship += ResultExpressionMember )?
    '}'
;
ReturnFeatureMember:
    MemberPrefix 'return'
    ownedMemberParameter = FeatureElement
    ;
ResultExpressionMember:
    MemberPrefix ownedResultExpression = OwnedExpression
    ;
/* =============================================================== */
/* EXPRESSIONS */
Expression:
    FeaturePrefix 'expr'
    ExpressionDeclaration FunctionBody
    ;
ExpressionDeclaration:
    FeatureDeclaration
    ( ValuePart | StepParameterList ReturnParameterPart? )?
    ;
/* =============================================================== */
/* PREDICATES */
Predicate:
    ( isAbstract ?= 'abstract' )? 'predicate'
    PredicateDeclaration FunctionBody
    ;
PredicateDeclaration:
    ( isSufficient ?= 'all' )? (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    ( ownedRelationship += OwnedMultiplicity )?
    (
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )* | ConjugationPart
    )?
    DisjoiningPart?
    ( ParameterList ReturnParameterPart? )?
    ;

/* =============================================================== */
/* BOOLEAN EXPRESSIONS AND INVARIANTS */
BooleanExpression:
    FeaturePrefix 'bool'
    ExpressionDeclaration FunctionBody
    ;
Invariant:
    FeaturePrefix 'inv' ( 'true' | isNegated ?= 'false' )?
    ExpressionDeclaration FunctionBody
    ;

/* =============================================================== */
/* OPERATOR EXPRESSIONS */
OwnedExpressionMember:
    ownedFeatureMember = OwnedExpression
    ;
OwnedExpression:
//    DECIMAL_VALUE
//      ConditionalExpression
      BinaryOperatorExpression
//      UnaryOperatorExpression
//      ClassificationExpression
//      ExtentExpression
//      PrimaryExpression

//      ConditionalExpression
//    | BinaryOperatorExpression
//    | UnaryOperatorExpression
//    | ClassificationExpression
//    | ExtentExpression
//    | PrimaryExpression
    ;
ConditionalExpression:
      'if' ownedRelationship += OwnedExpressionMember
      operator = '?'
      ownedRelationship += OwnedExpressionMember &'else'
      ownedRelationship += OwnedExpressionMember
    | ConditionalDeclaration
    ;

ConditionalDeclaration:
    ownedRelationship += OwnedExpressionMember
    operator = '?'
    ownedRelationship += OwnedExpressionMember &':'
    ownedRelationship += OwnedExpressionMember
    ;

BinaryOperatorExpression:
    ownedRelationship += OwnedExpressionMember
    operator = BinaryOperator
    ownedRelationship += OwnedExpressionMember
    ;

BinaryOperator:
      '??' | '||'  | '&&'  | '|'  | '&'
    | 'or' | 'and' | 'xor' | 'implies'
    | '==' | '!='  | '..'  | '<'  | '>'
    | '+'  | '-'   | '*'   | '/'  | '%'
    | '^^'
    | '<=' | '>='
;
UnaryOperatorExpression:
    operator = UnaryOperator
    ownedRelationship += OwnedExpressionMember
    ;
UnaryOperator:
    '+' | '-' | '!' | '~' | 'not'
    ;
ClassificationExpression:
    ( ownedRelationship += OwnedExpressionMember )?
    operator = ClassificationOperator
    ownedRelationship += TypeReferenceMember
    ;
ClassificationOperator:
    'istype' | 'hastype' | '@' | 'as'
    ;
ExtentExpression:
    operator = 'all'
    ownedRelationship += TypeReferenceMember
    ;
TypeReferenceMember:
    ownedMemberFeature = TypeReference
    ;
TypeReference:
    ownedRelationship += ReferenceTyping
    ;
ReferenceTyping:
    type = [QualifiedName]
    ;
/* =============================================================== */
/* PRIMARY EXPRESSIONS */
PrimaryExpression:
      FeatureChainExpression
    | NonFeatureChainPrimaryExpression
    ;
PrimaryExpressionMember:
    ownedMemberFeature = PrimaryExpression
    ;
NonFeatureChainPrimaryExpression:
      IndexExpression
    | SequenceExpression
    | SelectExpression
    | FunctionOperationExpression
    | BaseExpression
    ;
NonFeatureChainPrimaryExpressionMember:
    ownedMemberFeature = NonFeatureChainPrimaryExpression
    ;
IndexExpression:
    ownedRelationship += PrimaryExpressionMember
    operator = '['
    ownedRelationship += OwnedExpressionMember ']'
    ;
SequenceExpression:
    '(' ( OwnedExpression | SequenceExpressionList ) ','? ')'
    ;
SequenceExpressionList:
    ownedRelationship += OwnedExpressionMember
    operator = ','
    ( ownedRelationship += SequenceExpressionListMember
    | ownedRelationship += OwnedExpressionMember )
    ;
SequenceExpressionListMember:
    ownedMemberFeature = SequenceExpressionList
    ;
FeatureChainExpression:
    ownedRelationship += NonFeatureChainPrimaryExpressionMember '.'
    ownedRelationship += FeatureChainMember
    ;
CollectExpression :
    ownedRelationship += PrimaryExpressionMember '.'
    ownedRelationship += ExpressionBodyMember
    ;
SelectExpression:
    ownedRelationship += PrimaryExpressionMember '.?'
    ownedRelationship += ExpressionBodyMember
    ;
FunctionOperationExpression:
    ownedRelationship += PrimaryExpressionMember '->'
    ownedRelationship += ReferenceTyping
    ( ownedRelationship += ExpressionBodyMember
    | ownedRelationship += FunctionReferenceMember
    | ArgumentList )
    ;
ExpressionBodyMember:
    ownedMemberFeature = ExpressionBody
    ;
FunctionReferenceMember:
    ownedMemberFeature = FunctionReference
    ;
FunctionReference :
    ownedRelationship += ReferenceTyping
    ;
FeatureChainMember:
      memberElement = [QualifiedName]
    | ownedMemberElement = FeatureChain
    ;

/* =============================================================== */
/* BASE EXPRESSIONS */
BaseExpression:
      NullExpression
    | LiteralExpression
    | FeatureReferenceExpression
    | InvocationExpression
    | ExpressionBody
    ;
NullExpression:
    'null' | '(' ')'
    ;
FeatureReferenceExpression:
    ownedRelationship += FeatureReferenceMember
    ;
FeatureReferenceMember:
    memberElement = [QualifiedName]
    ;
InvocationExpression:
    ownedRelationship += OwnedSpecialization
    ArgumentList
    ;
ArgumentList:
    '(' ( PositionalArgumentList | NamedArgumentList )? ')'
    ;
PositionalArgumentList:
    ownedRelationship += OwnedExpressionMember
    ( ',' ownedRelationship += OwnedExpressionMember )*
    ;
NamedArgumentList:
    ownedRelationship += NamedExpressionMember
    ( ',' ownedRelationship += NamedExpressionMember )*
    ;
NamedExpressionMember:
    name=QualifiedName '=' ownedMemberFeature = OwnedExpression
    ;
ExpressionBody:
    FunctionBody
    ;
Interaction:
    ( isAbstract ?= 'abstract' )? 'interaction'
    BehaviorDeclaration
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;

/* =============================================================== */
/* LITERAL EXPRESSIONS */
LiteralExpression:
      LiteralBoolean
    | LiteralString
    | LiteralInteger
    | LiteralReal
    | LiteralInfinity
    ;
LiteralBoolean:
    value = BooleanValue
    ;
BooleanValue:
    'true' | 'false'
    ;
LiteralString:
    value = STRING_VALUE
    ;
LiteralInteger:
    value = DECIMAL_VALUE
    ;
LiteralReal:
    value = RealValue
    ;
RealValue:
      DECIMAL_VALUE? '.' ( DECIMAL_VALUE | EXPONENTIAL_VALUE )
    | EXPONENTIAL_VALUE
    ;
LiteralInfinity:
    '*'
    ;

/* =============================================================== */
/* ITEM FLOWS */
ItemFlow:
    FeaturePrefix 'flow'
    ItemFlowDeclaration
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;
SuccessionItemFlow:
    FeaturePrefix 'succession' 'flow'
    ItemFlowDeclaration
    (';' | '{'
    (
      documentation += OwnedDocumentation
    | ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
    )*
    '}')
    ;
ItemFlowDeclaration:
    ( FeatureDeclaration
      ( 'of'  ownedRelationship += ItemFeatureMember
      | ownedRelationship += EmptyItemFeatureMember )
      'from'
    | ( isSufficient ?= 'all' )?
      ownedRelationship += EmptyItemFeatureMember
    )
    ownedRelationship += ItemFlowEndMember 'to'
    ownedRelationship += ItemFlowEndMember
    ;
ItemFeatureMember:
    ( name= Name ':' )? ownedMemberFeature = ItemFeature
    ;
ItemFeature:
      ownedTyping += OwnedFeatureTyping
      ( ownedRelationship += OwnedMultiplicity )?
    | ownedRelationship += OwnedMultiplicity
      ( ownedTyping += OwnedFeatureTyping )?
      ;
EmptyItemFeatureMember:
    ownedMemberFeature = EmptyItemFeature
    ;
EmptyItemFeature:
    ''
    ;
ItemFlowEndMember:
    ownedMemberFeature = ItemFlowEnd
    ;
ItemFlowEnd:
    ( ownedRelationship += Subsetting '.' )?
    ownedRelationship += ItemFlowFeatureMember
    ;
ItemFlowFeatureMember:
    ownedMemberFeature = ItemFlowFeature
    ;
ItemFlowFeature:
    ownedRelationship += ItemFlowRedefinition
    ;
ItemFlowRedefinition:
    redefinedFeature = [QualifiedName]
    ;

/* =============================================================== */
/* FEATURE VALUES */
ValuePart:
    ownedRelationship += FeatureValue
;

FeatureValue:
    ( '='
    | isInitial ?= ':='
//    | isDefault ?= 'default' ( '=' | isInitialSecond ?= ':=' )?
    | IsInitial
    )
    value = OwnedExpression
;

IsInitial:
    isDefault ?= 'default' ( '=' | isInitial ?= ':=' )?
    ;

/* =============================================================== */
/* FEATURE VALUES */
Multiplicity:
    MultiplicitySubset | MultiplicityRange
    ;
MultiplicitySubset:
    'multiplicity' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? ( ':>'  | 'subsets' ) ownedRelationship += OwnedSubsetting ';'
    ;
MultiplicityRange:
    'multiplicity' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? MultiplicityBounds ';'
    ;
OwnedMultiplicity:
    ownedMemberElement = OwnedMultiplicityRange
    ;
OwnedMultiplicityRange:
    MultiplicityBounds
    ;
MultiplicityBounds:
    '[' ( ownedRelationship += MultiplicityExpressionMember '..' )?
          ownedRelationship += MultiplicityExpressionMember ']'
    ;
MultiplicityExpressionMember:
      ownedMemberElement = LiteralExpression
    | ownedMemberElement = FeatureReferenceExpression
    ;

/* =============================================================== */
/* METADATA */
AnnotatingFeature:
    ( '@' | 'metadata' ) AnnotatingFeatureDeclaration
    ( 'about' annotation += Annotation
//      { ownedRelationship += annotation }
      ( ',' annotation += Annotation
//        { ownedRelationship += annotation }
        )*
    | annotation += ElementAnnotation
//      { ownedRelationship += annotation }
    )
    AnnotatingFeatureBody
    ;
AnnotatingFeatureDeclaration:
    ( (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)? ( ':' | 'typed' 'by' ) )?
    ownedRelationship += OwnedFeatureTyping
    ;
AnnotatingFeatureBody:
    ';' | '{' ( ownedRelationship += MetadataFeatureMember )* '}'
    ;
MetadataFeatureMember:
    ownedMemberFeature = MetadataFeature
    ;
MetadataFeature:
    'feature'? ( ':>>' | 'redefines')? ownedRelationship += OwnedRedefinition
    '=' metadataFeatureValue = MetadataFeatureValue ';'
    ;
MetadataFeatureValue:
    metadataValue = OwnedExpression
    ;

/* =============================================================== */
/* PACKAGES */
Package:
    'package' (('<' humanId=QualifiedName '>' name=QualifiedName ) | ( '<' name=QualifiedName '>' ) | name=QualifiedName)?
    (';'
    | '{'
         (
           (
             ownedRelationship += OwnedDocumentation
             | ownedRelationship += NamespaceMember
             | ownedRelationship += AliasMember
             | ownedRelationship += Import
           )
           | ownedRelationship += ElementFilterMember
         )*
      '}'
    )
    ;

ElementFilterMember:
    MemberPrefix
    'filter' condition = OwnedExpression ';'
    ;

// This is only here to allow the class to be pulled in
Membership:
    'membership' name=QualifiedName memberElement=Element ownedMemberElement=Element visibility=VisibilityIndicator
;


/* =============================================================== */
/* TEXTX COMMENTS */
Comment:
    NoteBlock | NoteLine
;

NoteBlock:
    /\/\/\*(.|\n)*?\*\//
;

NoteLine:
    /\/\/.*$/
;

REGULAR_COMMENT:
//    commentText=/\/\*(.*?)\*\//
    commentText=/(?ms)\/\*(.*?)\*\//
;
//
DOCUMENTATION_COMMENT:
    commentText=/\/\*\*(.*?)\*\//
;

/* QualifiedNames */
Qualification:
    ('::' Name)*
    ;
QualifiedName[split='::']:
//    Name Qualification
    Name('::'Name)*
    ;

/* NAMES */
Name:
    !Keyword (BASIC_NAME | '\'' UNRESTRICTED_NAME '\'')
;
BASIC_NAME:
    /([a-zA-Z]|'_')([\w\d])*/
    ;
UNRESTRICTED_NAME:
    /((?!['"])([ -~])|(\\(b|t|n|f|r)))*/
    ;
DECIMAL_DIGIT:
//    /\'[0-9]\'/
    /[0-9]/
;

/* TERMINALS */
DECIMAL_VALUE:
//    : /'0'..'9' ('0'..'9')*/
//    : /\'[0-9]*\'/
    DECIMAL_DIGIT+
    ;

EXPONENTIAL_VALUE
    : DECIMAL_VALUE ('e' | 'E') ('+' | '-')? DECIMAL_VALUE
	;

STRING_VALUE
    : /'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | '"' | "'" | '\\') | !('\\' | '"'))* '"'/
    ;

TYPED_BY    : ':'   | 'typed' 'by';
SPECIALIZES : ':>'  | 'specializes';
SUBSETS     : ':>'  | 'subsets';
REDEFINES   : ':>>' | 'redefines';
CONJUGATES  : '~'   | 'conjugates';

Keyword:
    'element' | 'from' | 'to' | 'doc' | 'rep' |  'about'
//    'element' | 'from' | 'to' | 'doc' | 'rep' | 'language' | 'about'
//    |'package' | 'specialization' | 'import' | 'typed by' | 'subsets' | 'redefines' | 'conjugates'
;

//Keyword:
//    'about' | 'abstract' | 'alias' | 'all' | 'and' | 'as' | 'assign' | 'assoc' | 'behavior' | 'binding' | 'bool' | 'by' | 'class'
//    | 'classifier' | 'comment' | 'composite' | 'conjugate' | 'conjugates' | 'conjugation' | 'connector'
//    | 'datatype' | 'default' | 'disjoining' | 'disjoint' | 'doc' | 'element' | 'else' | 'end' | 'expr' | 'false'
//    | 'feature' | 'featured' | 'featuring' | 'filter' | 'first' | 'flow' | 'for' | 'from' | 'function' | 'generalization'
//    | 'hastype' | 'id' | 'if' | 'implies' | 'import' | 'in' | 'inout' | 'interaction' | 'inv' | 'is' | 'istype' | 'language'
//    | 'member' | 'metadata' | 'multiplicity' | 'namespace' | 'nonunique' | 'not' | 'null' | 'of' | 'or' | 'ordered' | 'out'
//    | 'package' | 'portion' | 'predicate' | 'private' | 'protected' | 'public' | 'redefines' | 'redefinition'
//    | 'relationship' | 'rep' | 'return' | 'specialization' | 'specializes' | 'step' | 'stream' | 'struct'
//    | 'subclassifier' | 'subset' | 'subsets' | 'subtype' | 'succession' | 'then' | 'to' | 'true' | 'type' | 'typed'
//    ;